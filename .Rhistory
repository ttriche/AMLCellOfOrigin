crossValidate <- function(data, k, method = "impute", reps = 5, n = 0.05, ...) {
verbose <- getOption("RcppML.verbose")
options("RcppML.verbose" = FALSE)
if(!(method %in% c("impute", "predict", "robust", "perturb"))) stop("'method' must be one of 'impute', 'predict', 'robust', or 'perturb'")
p <- list(...)
defaults <- list("mask" = NULL, "perturb_to_" = "random")
for (i in 1:length(defaults))
if (is.null(p[[names(defaults)[[i]]]])) p[[names(defaults)[[i]]]] <- defaults[[i]]
seed <- NULL
if(!is.null(p$seed)) {
seed <- p$seed
p$seed <- NULL
}
if(!is.null(p$mask)){
if(method == "impute") stop("method = 'impute' is not supported for arguments to 'mask'")
if(method == "perturb" && getOption("RcppML.verbose"))
warning("method = 'perturb' does not consider masking parameters during evaluation of the mean squared error of perturbed values")
if(!is.character(p$mask)){
if(canCoerce(p$mask, "ngCMatrix")){
p$mask <- as(p$mask, "ngCMatrix")
} else if(canCoerce(p$mask, "matrix")){
p$mask <- as(as.matrix(p$mask), "ngCMatrix")
} else stop("supplied masking value was invalid or not coercible to a matrix")
}
}
results <- list()
for(rep in 1:reps){
if(verbose) cat("\nReplicate ", rep, ", rank: ", sep = "")
# get samples, features, or missing values for test/training/cross-validation
if(method == "predict" || method == "robust"){
if(!is.null(seed)) set.seed(seed + rep)
samples <- sample(1:ncol(data), floor(ncol(data) * 0.5))
}
if(method == "predict"){
if(!is.null(seed)) set.seed(seed + rep)
features <- sample(1:nrow(data), floor(nrow(data) * 0.5))
}
if(method == "impute"){
if(!is.null(seed)) set.seed(seed + rep)
mask_matrix <- rsparsematrix(nrow(data), ncol(data), n, rand.x = NULL)
}
if(method == "perturb"){
if(canCoerce(data, "dgCMatrix")) {
data <- as(data, "dgCMatrix")
mask_matrix <- as(data, "dgTMatrix")
} else {
data <- as(as.matrix(data), "dgCMatrix")
mask_matrix <- as(data, "dgTMatrix")
}
if(!is.null(seed)) set.seed(seed + rep)
ind <- sample(1:length(data@x), length(data@x) * n)
ind_vals <- data@x[ind]
if(p$perturb_to == "random"){
if(!is.null(seed)) set.seed(seed + rep)
perturb_vals <- sample(data@x, length(ind))
data@x[ind] <- perturb_vals
} else {
data@x[ind] <- 0
}
mask_matrix <- new("ngTMatrix", i = mask_matrix@i[ind], j = mask_matrix@j[ind], Dim = mask_matrix@Dim)
mask_matrix <- as(mask_matrix, "ngCMatrix")
}
for(rank in k){
if(verbose) cat(rank, " ")
mask_22 <- mask_21 <- mask_11 <- mask_w1 <- mask_w2 <- p$mask
if(method == "predict"){
if(is(p$mask, "ngCMatrix")){
mask_22 <- p$mask[-features, -samples]
mask_21 <- p$mask[-features, samples]
mask_11 <- p$mask[features, samples]
}
m22 <- nmf(data[-features, -samples], rank, mask = mask_22, ...)
m21 <- predict.nmf(m22$w, data[-features, samples], mask = mask_21)
m11 <- predict.nmf(m21, t(data[features, samples]), mask = mask_11)
m <- new("nmf", "w" = t(m11), "d" = rep(1, rank), "h" = m21)
value <- evaluate(m, data[features, samples], mask = mask_11)
} else if(method == "robust"){
if(is(p$mask, "ngCMatrix")){
mask_w1 <- p$mask[, samples]
mask_w2 <- p$mask[, -samples]
}
w1 <- nmf(data[, samples], rank, mask = mask_w1, ...)$w
w2 <- nmf(data[, -samples], rank, mask = mask_w2, ...)$w
value <- bipartiteMatch(1 - cosine(w1, w2))$cost / rank
} else if(method == "impute"){
m <- nmf(data, rank, mask = mask_matrix, seed = (seed + rep), ...)
value <- evaluate(m, data, mask = mask_matrix, missing_only = TRUE)
} else if(method == "perturb") {
m <- nmf(data, rank, ...)
data@x[ind] <- ind_vals
value <- evaluate(m, data, mask = mask_matrix, missing_only = TRUE)
if(p$perturb_to == "random"){
data@x[ind] <- perturb_vals
} else {
data@x[ind] <- 0
}
}
results[[length(results) + 1]] <- c(rep, rank, value)
}
}
results <- data.frame(do.call(rbind, results))
colnames(results) <- c("rep", "k", "value")
class(results) <- c("nmfCrossValidate", "data.frame")
results$rep <- as.factor(results$rep)
options("RcppML.verbose" = verbose)
return(results)
}
cv <- crossValidate(aml, 1:15, seed = 123)
p
cv <- crossValidate(aml, 1:15)
#' Cross-validation for NMF
#'
#' @description Find an "optimal" rank for a Non-Negative Matrix Factorization using cross-validation. Returns a \code{data.frame} with class \code{nmfCrossValidate}. Plot results using the \code{plot} S3 method.
#'
#' @details
#' Two algorithms are available for cross-validation and can be selected using the \code{method} parameter:
#'
#' 1. **Bi-cross-validation**: Data is split into an equally-sized 2x2 grid (A1, A2, B1, and B2). Data is trained on A1 and projected to A2 to B2 where the mean squared error of the model on B2 is measured.
#' 2. **Cost of bipartite matching** between independent replicates. Samples are partitioned into two sets and independently factorized, then correlation between factors in both \code{w} models is computed, factors are matched using bipartite matching on a cosine similarity cost matrix, and the mean cost of matched factors is returned.
#'
#' @inheritParams nmf
#' @param k array of factorization ranks to test
#' @param method algorithm to use for cross-validation: "\code{predict}" = bi-cross-validation on equally sized feature/sample subsets, "\code{impute}" = MSE of missing value imputation, "\code{robust}" = mean cost of bipartite matching between models trained on equally sized non-overlapping sample sets.
#' @param reps number of independent replicates to run
#' @param n for \code{method = "impute"} and \code{"perturb"}, fraction of values to handle as missing
#' @param ... parameters to \code{RcppML::nmf}, not including \code{data} or \code{k}
#' @return \code{data.frame} with columns \code{rep}, \code{k}, and \code{value}, where \code{value} depends on the \code{method} selected (i.e. MSE, cost of bipartite matching)
#' @md
#' @seealso \code{\link{nmf}}
#' @export
crossValidate <- function(data, k, method = "impute", reps = 5, n = 0.05, ...) {
verbose <- getOption("RcppML.verbose")
options("RcppML.verbose" = FALSE)
if(!(method %in% c("impute", "predict", "robust", "perturb"))) stop("'method' must be one of 'impute', 'predict', 'robust', or 'perturb'")
p <- list(...)
defaults <- list("mask" = NULL, "perturb_to_" = "random")
for (i in 1:length(defaults))
if (is.null(p[[names(defaults)[[i]]]])) p[[names(defaults)[[i]]]] <- defaults[[i]]
if(!is.null(p$mask)){
if(method == "impute") stop("method = 'impute' is not supported for arguments to 'mask'")
if(method == "perturb" && getOption("RcppML.verbose"))
warning("method = 'perturb' does not consider masking parameters during evaluation of the mean squared error of perturbed values")
if(!is.character(p$mask)){
if(canCoerce(p$mask, "ngCMatrix")){
p$mask <- as(p$mask, "ngCMatrix")
} else if(canCoerce(p$mask, "matrix")){
p$mask <- as(as.matrix(p$mask), "ngCMatrix")
} else stop("supplied masking value was invalid or not coercible to a matrix")
}
}
results <- list()
for(rep in 1:reps){
if(verbose) cat("\nReplicate ", rep, ", rank: ", sep = "")
# get samples, features, or missing values for test/training/cross-validation
if(method == "predict" || method == "robust"){
if(!is.null(p$seed)) set.seed(p$seed + rep)
samples <- sample(1:ncol(data), floor(ncol(data) * 0.5))
}
if(method == "predict"){
if(!is.null(p$seed)) set.seed(p$seed + rep)
features <- sample(1:nrow(data), floor(nrow(data) * 0.5))
}
if(method == "impute"){
if(!is.null(p$seed)) set.seed(p$seed + rep)
mask_matrix <- rsparsematrix(nrow(data), ncol(data), n, rand.x = NULL)
}
if(method == "perturb"){
if(canCoerce(data, "dgCMatrix")) {
data <- as(data, "dgCMatrix")
mask_matrix <- as(data, "dgTMatrix")
} else {
data <- as(as.matrix(data), "dgCMatrix")
mask_matrix <- as(data, "dgTMatrix")
}
if(!is.null(p$seed)) set.seed(p$seed + rep)
ind <- sample(1:length(data@x), length(data@x) * n)
ind_vals <- data@x[ind]
if(p$perturb_to == "random"){
if(!is.null(p$seed)) set.seed(p$seed + rep)
perturb_vals <- sample(data@x, length(ind))
data@x[ind] <- perturb_vals
} else {
data@x[ind] <- 0
}
mask_matrix <- new("ngTMatrix", i = mask_matrix@i[ind], j = mask_matrix@j[ind], Dim = mask_matrix@Dim)
mask_matrix <- as(mask_matrix, "ngCMatrix")
}
for(rank in k){
if(verbose) cat(rank, " ")
mask_22 <- mask_21 <- mask_11 <- mask_w1 <- mask_w2 <- p$mask
if(method == "predict"){
if(is(p$mask, "ngCMatrix")){
mask_22 <- p$mask[-features, -samples]
mask_21 <- p$mask[-features, samples]
mask_11 <- p$mask[features, samples]
}
m22 <- nmf(data[-features, -samples], rank, mask = mask_22, ...)
m21 <- predict.nmf(m22$w, data[-features, samples], mask = mask_21)
m11 <- predict.nmf(m21, t(data[features, samples]), mask = mask_11)
m <- new("nmf", "w" = t(m11), "d" = rep(1, rank), "h" = m21)
value <- evaluate(m, data[features, samples], mask = mask_11)
} else if(method == "robust"){
if(is(p$mask, "ngCMatrix")){
mask_w1 <- p$mask[, samples]
mask_w2 <- p$mask[, -samples]
}
w1 <- nmf(data[, samples], rank, mask = mask_w1, ...)$w
w2 <- nmf(data[, -samples], rank, mask = mask_w2, ...)$w
value <- bipartiteMatch(1 - cosine(w1, w2))$cost / rank
} else if(method == "impute"){
m <- nmf(data, rank, mask = mask_matrix, ...)
value <- evaluate(m, data, mask = mask_matrix, missing_only = TRUE)
} else if(method == "perturb") {
m <- nmf(data, rank, ...)
data@x[ind] <- ind_vals
value <- evaluate(m, data, mask = mask_matrix, missing_only = TRUE)
if(p$perturb_to == "random"){
data@x[ind] <- perturb_vals
} else {
data@x[ind] <- 0
}
}
results[[length(results) + 1]] <- c(rep, rank, value)
}
}
results <- data.frame(do.call(rbind, results))
colnames(results) <- c("rep", "k", "value")
class(results) <- c("nmfCrossValidate", "data.frame")
results$rep <- as.factor(results$rep)
options("RcppML.verbose" = verbose)
return(results)
}
cv <- crossValidate(aml, 1:15)
cv
plot(cv)
sort(cv$seed, decreasing = TRUE)
sort(cv$value, decreasing = TRUE)
plot(cv) +
theme(aspect.ratio = 1) + scale_y_continuous(limits = c(0.02, 0.04))
plot(cv) +
theme(aspect.ratio = 1) + scale_y_continuous(limits = c(0.02, 0.04)) +
stat_smooth(se = F, color = "black")
nmf5 <- nmf(aml, k = 5, seed = 123)
nmf10 <- nmf(aml, k = 10, seed = 123)
plot(summary(nmf10, group_by = colnames(aml), stat = "mean")) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00")) +
theme(aspect.ratio = 1)
nmf10 <- nmf(aml, k = 10, seed = 123)
plot(summary(nmf10, group_by = colnames(aml), stat = "mean")) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00")) +
theme(aspect.ratio = 1)
nmf10 <- nmf(aml, k = 10, seed = 123)
plot(summary(nmf10, group_by = colnames(aml), stat = "mean")) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00")) +
theme(aspect.ratio = 1)
plot_umap(nmf5[c(3, 7, 10)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
plot_umap(nmf10[c(3, 7, 10)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
plot_umap(nmf10[-c(1, 2, 6)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
plot_umap(nmf10[-c(2, 6)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
set.seed(123)
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
devtools::document()
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine") +
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine")
set.seed(123)
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
set.seed(123)
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
library(Seurat)
?`DimReduc-Class`
?`DimReduc-class`
data <- aml
A <- CreateSeuratObject(data)
A@reductions$nmf <- new("DimReduc", cell.embeddings = nmf_model$h, feature.loadings = nmf_model$w, stdev = nmf_model$d)
m <- nmf(aml, 10)
nmf_model <- m
A <- CreateSeuratObject(data)
A@reductions$nmf <- new("DimReduc", cell.embeddings = nmf_model$h, feature.loadings = nmf_model$w, stdev = nmf_model$d)
if(is.null(rownames(data))) rownames <- paste0("DMR", 1:nrow(data))
A <- CreateSeuratObject(data)
if(is.null(rownames(data))) rownames(data) <- paste0("DMR", 1:nrow(data))
A <- CreateSeuratObject(data)
A
A <- suppressWarnings(CreateSeuratObject(data))
A
str(A)
A@reductions$nmf <- new("DimReduc", cell.embeddings = nmf_model$h, feature.loadings = nmf_model$w, stdev = nmf_model$d)
str(A)
?FindNeighbors
A <- FindNeighbors(A, annoy.metric = "cosine", verbose = FALSE, k.param = 20, reduction = "nmf", dims = 1:ncol(nmf_model$w))
str(A)
A <- FindNeighbors(A, annoy.metric = "cosine", verbose = FALSE, k.param = 20, assay = "RNA", reduction = "nmf", dims = 1:ncol(nmf_model$w))
reductions(A)
str(A@reductions)
A@reductions$nmf <- new("DimReduc", cell.embeddings = nmf_model$h, feature.loadings = nmf_model$w, stdev = nmf_model$d, key = "nmf")
A <- FindNeighbors(A, annoy.metric = "cosine", verbose = FALSE, k.param = 20, reduction = "nmf", dims = 1:ncol(nmf_model$w))
dim(A)
dim(A@reductions$nmf@cell.embeddings)
A@reductions$nmf <- new("DimReduc", cell.embeddings = t(nmf_model$h), feature.loadings = nmf_model$w, stdev = nmf_model$d, key = "nmf")
A <- FindNeighbors(A, annoy.metric = "cosine", verbose = FALSE, k.param = 20, reduction = "nmf", dims = 1:ncol(nmf_model$w))
1:ncol(nmf_model$w)
A <- FindNeighbors(A, annoy.metric = "cosine", verbose = FALSE, k.param = 20, reduction = "nmf", dims = 1:ncol(nmf_model$w))
A <- FindNeighbors(A, annoy.metric = "cosine", verbose = FALSE, k.param = 20, reduction = "nmf", dims = 1:ncol(nmf_model$w), name = "nmf_nn")
str(A)
A <- suppressWarnings(CreateSeuratObject(data))
A@reductions$nmf <- new("DimReduc", cell.embeddings = t(nmf_model$h), feature.loadings = nmf_model$w, stdev = nmf_model$d, key = "nmf")
str(A)
A <- FindNeighbors(A, annoy.metric = "cosine", verbose = FALSE, k.param = 20, reduction = "nmf", dims = 1:ncol(nmf_model$w))
?make.names
A <- FindNeighbors(A, k.param = 20, reduction = "nmf", dims = 1:ncol(nmf_model$w))
?CreateDimReducObject
A@reductions$nmf <- CreateDimReducObject(embeddings = t(nmf_model$h), loadings = nmf_model$w, stdev = nmf_model$d, key = "nmf")
A@reductions$nmf <- CreateDimReducObject(embeddings = t(nmf_model$h), loadings = nmf_model$w, stdev = nmf_model$d, key = "nmf_", assay = "RNA")
str(A)
A <- FindNeighbors(A, k.param = 20, reduction = "nmf", dims = 1:ncol(nmf_model$w))
A <- FindNeighbors(A, k.param = 10, reduction = "nmf", dims = 1:ncol(nmf_model$w))
A <- RunPCA(A)
A <- FindVariableFeatures(A)
A <- RunPCA(A)
A <- ScaleData(A)
A <- RunPCA(A)
A <- FindNeighbors(A, k.param = 20, reduction = "pca", dims = 1:ncol(nmf_model$w))
str(A)
rownames(A@reductions$nmf$embeddings) <- colnames(A@assays$RNA@counts)
rownames(A@reductions$nmf@embeddings) <- colnames(A@assays$RNA@counts)
rownames(A@reductions$nmf@cell.embeddings) <- colnames(A@assays$RNA@counts)
if(is.null(rownames(data))) rownames(data) <- paste0("DMR", 1:nrow(data))
A <- suppressWarnings(CreateSeuratObject(data))
A@reductions$nmf <- CreateDimReducObject(embeddings = t(nmf_model$h), loadings = nmf_model$w, stdev = nmf_model$d, key = "nmf_", assay = "RNA")
rownames(A@reductions$nmf@cell.embeddings) <- colnames(A@assays$RNA@counts)
A <- FindNeighbors(A, k.param = 10, reduction = "nmf", dims = 1:ncol(nmf_model$w))
str(A)
?FindClusters
A <- FindClusters(A, resolution = resolution, verbose = FALSE)
resolution <- 1
A <- FindClusters(A, resolution = resolution, verbose = FALSE)
str(A)
cluster_nmf <- function(nmf_model, data, resolution = 1){
if(is.null(rownames(data))) rownames(data) <- paste0("DMR", 1:nrow(data))
A <- suppressWarnings(CreateSeuratObject(data))
A@reductions$nmf <- CreateDimReducObject(embeddings = t(nmf_model$h), loadings = nmf_model$w, stdev = nmf_model$d, key = "nmf_", assay = "RNA")
rownames(A@reductions$nmf@cell.embeddings) <- colnames(A@assays$RNA@counts)
A <- FindNeighbors(A, k.param = 10, reduction = "nmf", dims = 1:ncol(nmf_model$w))
A <- FindClusters(A, resolution = resolution, verbose = FALSE)
return(A@assays$RNA@seurat_clusters)
}
cluster_nmf(nmf(aml, 10))
cluster_nmf <- function(nmf_model, data, resolution = 1){
rownames(data) <- paste0("feature", 1:nrow(data))
colnames(data) <- paste0("sample", 1:ncol(data))
A <- suppressWarnings(CreateSeuratObject(data))
A@reductions$nmf <- CreateDimReducObject(embeddings = t(nmf_model$h), loadings = nmf_model$w, stdev = nmf_model$d, key = "nmf_", assay = "RNA")
rownames(A@reductions$nmf@cell.embeddings) <- colnames(A@assays$RNA@counts)
A <- FindNeighbors(A, k.param = 10, reduction = "nmf", dims = 1:ncol(nmf_model$w))
A <- FindClusters(A, resolution = resolution, verbose = FALSE)
return(A@assays$RNA@seurat_clusters)
}
cluster_nmf(m)
cluster_nmf(m, aml)
str(A)
devtools::document()
cluster_nmf(m)
cluster_nmf(m, aml)
rm(cluster_nmf)
devtools::document()
cluster_nmf(m, aml)
str(A)
devtools::document()
cluster_nmf(m, aml)
as.vector(cluster_nmf(m, aml))
devtools::document()
cluster_nmf(m, aml)
clusters <- cluster_nmf(nmf5[-3], aml)
colnames(nmf5@h) <- paste0("cluster", clusters)
plot_umap(nmf5[-3], n_neighbors = 10, metric = "cosine")
devtools::document()
set.seed(123)
plot_umap(nmf5[-3], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1)
set.seed(123)
plot_umap(nmf5[-3], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
nmf5 <- nmf(aml, k = 5, seed = 123)
set.seed(123)
plot_umap(nmf5[-3], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
plot(summary(nmf5, group_by = colnames(aml), stat = "mean")) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00")) +
theme(aspect.ratio = 1)
nmf5 <- nmf(aml, k = 5, seed = 123)
set.seed(123)
plot_umap(nmf5, n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
plot(summary(nmf5, group_by = colnames(aml), stat = "mean")) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00")) +
theme(aspect.ratio = 1)
summary(nmf5, group_by = colnames(aml), stat = "mean")
sample_representation <- summary(nmf5, group_by = colnames(aml), stat = "mean")
plot(sample_representation) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
sample_representation <- summary(nmf5, group_by = colnames(aml), stat = "mean")
plot(sample_representation) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
theme(aspect.ratio = 1)
sample_representation <- summary(nmf5, group_by = colnames(aml), stat = "mean")
plot(sample_representation) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
theme(aspect.ratio = 1)
biplot(nmf5, factors = c(3, 5), matrix = "h", group_by = colnames(aml)) +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
sample_Representation
sample_representation
min_aml <- subset(sample_representation, group == "AML sample")
min_aml
aml_min <- aml_representation$factor[which.min(aml_representation$stat)]
aml_representation <- subset(sample_representation, group == "AML sample")
aml_min <- aml_representation$factor[which.min(aml_representation$stat)]
aml_min
aml_max <- aml_representation$factor[which.max(aml_representation$stat)]
aml_max
aml_min <- which.min(aml_representation$stat)
aml_max <- which.max(aml_representation$stat)
aml_min
aml_max
biplot(nmf5, factors = c(aml_min, aml_max), matrix = "h", group_by = colnames(aml)) +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
nmf5 <- nmf(aml, k = 5, seed = 1:10, tol = 1e-10)
set.seed(123)
plot_umap(nmf5, n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
sample_representation <- summary(nmf5, group_by = colnames(aml), stat = "mean")
plot(sample_representation) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
theme(aspect.ratio = 1)
aml_representation <- subset(sample_representation, group == "AML sample")
aml_min <- which.min(aml_representation$stat)
aml_max <- which.max(aml_representation$stat)
biplot(nmf5, factors = c(aml_min, aml_max), matrix = "h", group_by = colnames(aml)) +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
aml_min
aml_max
set.seed(123)
plot_umap(nmf5[-aml_min], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
clusters <- cluster_nmf(nmf5[-3], aml)
colnames(nmf5@h) <- paste0("cluster", clusters)
plot_umap(nmf5[-3], n_neighbors = 10, metric = "cosine")
clusters <- cluster_nmf(nmf5[-3], aml)
colnames(nmf5@h) <- paste0("cluster", clusters)
plot_umap(nmf5[-aml_min], n_neighbors = 10, metric = "cosine")
clusters <- cluster_nmf(nmf5[-3], aml, resolution = 0.5)
colnames(nmf5@h) <- paste0("cluster", clusters)
plot_umap(nmf5[-aml_min], n_neighbors = 10, metric = "cosine")
clusters <- cluster_nmf(nmf5[-3], aml, resolution = 0.1)
colnames(nmf5@h) <- paste0("cluster", clusters)
plot_umap(nmf5[-aml_min], n_neighbors = 10, metric = "cosine")
clusters <- cluster_nmf(nmf5[-aml_min], aml, resolution = 0.1)
colnames(nmf5@h) <- paste0("cluster", clusters)
plot_umap(nmf5[-aml_min], n_neighbors = 10, metric = "cosine")
cv <- crossValidate(aml, 1:15, seed = 123)
plot(cv) +
theme(aspect.ratio = 1) + scale_y_continuous(limits = c(0.02, 0.04)) +
stat_smooth(se = F, color = "black")
cv <- crossValidate(aml, 1:15, seed = 123)
plot(cv) +
theme(aspect.ratio = 1) + scale_y_continuous(limits = c(0.02, 0.04)) +
stat_smooth(se = F, color = "black")
cv <- crossValidate(aml, 2:15, seed = 123, reps = 3)
plot(cv) +
theme(aspect.ratio = 1) + scale_y_continuous(limits = c(0.02, 0.03)) +
stat_smooth(se = F, color = "black")
cv <- crossValidate(aml, 2:15, seed = 123, reps = 5)
plot(cv) +
theme(aspect.ratio = 1) + scale_y_continuous(limits = c(0.02, 0.03)) +
stat_smooth(se = F, color = "black")
nmf10 <- nmf(aml, k = 10, seed = 123)
plot(summary(nmf10, group_by = colnames(aml), stat = "mean")) +
scale_fill_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00")) +
theme(aspect.ratio = 1)
set.seed(123)
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine") +
theme(aspect.ratio = 1) +
scale_color_manual(values = c("gray", "#F8766D", "#C77CFF", "#7CAE00"))
clusters <- cluster_nmf(nmf5[-aml_min], aml, resolution = 0.1)
colnames(nmf5@h) <- paste0("cluster", clusters)
plot_umap(nmf5[-aml_min], n_neighbors = 10, metric = "cosine")
clusters <- cluster_nmf(nmf10[c(1, 7, 10)], aml, resolution = 0.1)
colnames(nmf10@h) <- paste0("cluster", clusters)
plot_umap(nmf10[c(1, 7, 10)], n_neighbors = 10, metric = "cosine")
clusters <- cluster_nmf(nmf10, aml, resolution = 0.1)
colnames(nmf10@h) <- paste0("cluster", clusters)
plot_umap(nmf10, n_neighbors = 10, metric = "cosine")
rm(list = ls())
